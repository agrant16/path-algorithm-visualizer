(this["webpackJsonppath-algorithm-visualizer"]=this["webpackJsonppath-algorithm-visualizer"]||[]).push([[0],{39:function(e,t,a){e.exports=a(56)},45:function(e,t,a){},46:function(e,t,a){},47:function(e,t,a){},54:function(e,t,a){},55:function(e,t,a){},56:function(e,t,a){"use strict";a.r(t);var n=a(0),i=a.n(n),r=a(20),s=a.n(r),o=(a(44),a(45),a(46),a(6)),l=a(7),d=a(11),u=a(10),c=a(14),h=a(12),v=a(24),g=a(28),f=a(38),m=a(15),p=(a(47),function(e){function t(){return Object(o.a)(this,t),Object(d.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(l.a)(t,[{key:"render",value:function(){var e=this;return i.a.createElement("div",null,i.a.createElement(g.a,{expand:"lg",bg:"dark",variant:"dark"},i.a.createElement(g.a.Brand,{href:"."},"Pathfinding Algorithm Visualizer"),i.a.createElement(g.a.Toggle,{"aria-controls":"basic-navbar-nav"}),i.a.createElement(g.a.Collapse,{id:"basic-navbar-nav"},i.a.createElement(f.a,{className:"mr-auto",disabled:this.props.visualized},i.a.createElement(m.a,{title:"Algorithms",id:"basic-nav-dropdown",className:"my-dropdown"},i.a.createElement(m.a.Item,{href:"#",className:"my-dropdown-item",onClick:function(){return e.props.changeAlgo("Dijkstra")}},"Djikstra's"),i.a.createElement(m.a.Item,{href:"#",className:"my-dropdown-item",onClick:function(){return e.props.changeAlgo("Bellman-Ford")}},"Bellman-Ford"),i.a.createElement(m.a.Item,{href:"#",className:"my-dropdown-item",onClick:function(){return e.props.changeAlgo("BFS")}},"BFS"),i.a.createElement(m.a.Item,{href:"#",className:"my-dropdown-item",onClick:function(){return e.props.changeAlgo("DFS")}},"DFS")),i.a.createElement(v.a,{className:"non-visualize-button",onClick:this.props.changeWeights,disabled:this.props.visualized},"New Weights"),i.a.createElement(v.a,{className:"visualize-it-button",onClick:this.props.visualize,disabled:this.props.visualized},"Visualize It!"),i.a.createElement(v.a,{className:"non-visualize-button",onClick:this.props.clearBoard,disabled:this.props.visualized},"Clear Board"),i.a.createElement(m.a,{title:"Maze Algorithms",id:"basic-nav-dropdown",className:"my-dropdown"},i.a.createElement(m.a.Item,{href:"#",className:"my-dropdown-item",onClick:function(){e.props.generateMaze("Random")}},"Random Walls"),i.a.createElement(m.a.Item,{href:"#",className:"my-dropdown-item",onClick:function(){e.props.generateMaze("RecursiveDivision")}},"Recursive Division"))))))}}]),t}(n.Component)),b=(a(54),function(e){function t(){return Object(o.a)(this,t),Object(d.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(l.a)(t,[{key:"render",value:function(){var e=this.props,t=e.col,a=e.row,n=(e.isEnd,e.isStart,e.isVisited,e.isWall,e.onMouseDown),r=e.onMouseEnter,s=e.onMouseUp,o=e.weight;return i.a.createElement("div",{className:"node-box"},i.a.createElement("div",{id:"node-".concat(a,"-").concat(t),className:"node ".concat(w(this.props)),onMouseDown:function(){return n(a,t)},onMouseEnter:function(){return r(a,t)},onMouseUp:function(){return s()}},i.a.createElement("p",null,o)))}}]),t}(n.Component)),w=function(e){return e.isEnd?"node-end":e.isStart?"node-start":e.isWall?"node-wall":" "},y=function(){function e(){Object(o.a)(this,e),this.visitedSpeed=10,this.shortestSpeed=50}return Object(l.a)(e,[{key:"animate",value:function(e,t){for(var a=this,n=function(n){if(n===e.length)return setTimeout((function(){a.animateShortestPath(t)}),10*n),{v:void 0};setTimeout((function(){var t=e[n];document.getElementById("node-".concat(t.row,"-").concat(t.col)).className="node node-visited"}),a.visitedSpeed*n)},i=0;i<=e.length;i++){var r=n(i);if("object"===typeof r)return r.v}}},{key:"animateShortestPath",value:function(e){for(var t=this,a=function(a){setTimeout((function(){var t=e[a];document.getElementById("node-".concat(t.row,"-").concat(t.col)).className="node node-shortest-path"}),t.shortestSpeed*a)},n=0;n<e.length;n++)a(n)}},{key:"updateSpeed",value:function(e,t){this.visitedSpeed=e,this.shortestSpeed=t}}]),e}(),k=function(){function e(){Object(o.a)(this,e)}return Object(l.a)(e,[{key:"getUnvisitedNeighbors",value:function(e,t){var a=[],n=e.col,i=e.row;return i>0&&a.push(t[i-1][n]),i<t.length-1&&a.push(t[i+1][n]),n>0&&a.push(t[i][n-1]),n<t[0].length-1&&a.push(t[i][n+1]),(a=a.filter((function(e){return!e.isVisited}))).filter((function(e){return!e.isWall}))}},{key:"getShortestPath",value:function(e,t){for(var a=[],n=t;null!==n&&n!==e;)a.unshift(n),n=n.previous;return a.unshift(e),a}},{key:"getAllNodes",value:function(e){for(var t=[],a=0;a<19;a++)for(var n=0;n<49;n++)e[a][n].isVisited||e[a][n].isWall||t.push(e[a][n]);return t}}]),e}(),E=function(e){function t(){return Object(o.a)(this,t),Object(d.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(l.a)(t,[{key:"traverse",value:function(e,t,a){var n=[];t.distance=0,t.weight=0;for(var i=this.getAllNodes(e);0!==i.length;){this.sortNodesByDistance(i);var r=i.shift();if(r.distance===1/0)return n;if(r.isVisited=!0,n.push(r),r===a)return n;var s=this.getUnvisitedNeighbors(r,e),o=!0,l=!1,d=void 0;try{for(var u,c=s[Symbol.iterator]();!(o=(u=c.next()).done);o=!0){var h=u.value,v=r.distance+h.weight;v<h.distance&&(h.distance=v,h.previous=r)}}catch(g){l=!0,d=g}finally{try{o||null==c.return||c.return()}finally{if(l)throw d}}}}},{key:"sortNodesByDistance",value:function(e){e.sort((function(e,t){return e.distance-t.distance}))}}]),t}(k);E.weighted=!0,E.text="Dijkstra's shortest path algorithm works on weighted graphs and\nguarantees the shortest path. This algorithm works similarly to breadth-first\nsearch in that it begins at the start node and then works it's way outward in\nall directions. As it works outwards it checks the edges (u,v,w) to see if\nu.distance + w is less than v.distance. If so it updates v.distance to hold\nu.distance + w. It continues this process until no more nodes can be visited,\nor until the destination node is found.";var S=function(e){function t(){return Object(o.a)(this,t),Object(d.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(l.a)(t,[{key:"traverse",value:function(e,t,a){var n=[],i=[];for(t.isVisted=!0,t.previous=null,n.push(t),i.push(t);0!==n.length;){var r=n.shift();if(r===a)return i;var s=this.getUnvisitedNeighbors(r,e),o=!0,l=!1,d=void 0;try{for(var u,c=s[Symbol.iterator]();!(o=(u=c.next()).done);o=!0){var h=u.value;h.isVisited=!0,h.previous=r,n.push(h),i.push(h)}}catch(v){l=!0,d=v}finally{try{o||null==c.return||c.return()}finally{if(l)throw d}}}return i}}]),t}(k);S.weighted=!1,S.text="Breadth-first search works on unweighted graphs and\n  guarantees the shortest path. This algorithm works by beginning at the\n  starting node and visiting each of its neighbors. It then moves to\n  each neighbor and visits any of its unvisited neighbors. It repeats this\n  process spreading out across the graph until all nodes that can be visited\n  have been, or until we reach the destination node.";var j=function(e){function t(){return Object(o.a)(this,t),Object(d.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(l.a)(t,[{key:"traverse",value:function(e,t,a){var n=[],i=[];for(t.isVisted=!0,t.previous=null,n.push(t),i.push(t);0!==n.length;){var r=n.pop();if(r===a)return i;i.push(r);var s=this.getUnvisitedNeighbors(r,e),o=!0,l=!1,d=void 0;try{for(var u,c=s[Symbol.iterator]();!(o=(u=c.next()).done);o=!0){var h=u.value;h.isVisited=!0,h.previous=r,n.push(h)}}catch(v){l=!0,d=v}finally{try{o||null==c.return||c.return()}finally{if(l)throw d}}}return i}}]),t}(k);j.weighted=!1,j.text="Depth-first search works on unweighted graphs and does not\n  guarantee the shortest path. This algorithm visits one node at a time,\n  moving along the graph edges until it comes to a node with no unvisited\n  neighbors. It then backtracks to a node which has unvisited neighbors and\n  moves forward down that path. It repeats this until all nodes that can\n  be visited have been, or until it reaches the destination node.";var O=function(e){function t(){return Object(o.a)(this,t),Object(d.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(l.a)(t,[{key:"traverse",value:function(e,t,a){var n=[],i=this.getAllNodes(e);t.previous=null,t.distance=0,n.push(t);for(var r=0;r<i.length-1;r++){var s=!0,o=!1,l=void 0;try{for(var d,u=i[Symbol.iterator]();!(s=(d=u.next()).done);s=!0){var c=d.value,h=this.getUnvisitedNeighbors(c,e),v=!0,g=!1,f=void 0;try{for(var m,p=h[Symbol.iterator]();!(v=(m=p.next()).done);v=!0){var b=m.value,w=c.distance+b.weight;w<b.distance&&(b.distance=w,b.previous=c,n.includes(b)||n.push(b))}}catch(y){g=!0,f=y}finally{try{v||null==p.return||p.return()}finally{if(g)throw f}}}}catch(y){o=!0,l=y}finally{try{s||null==u.return||u.return()}finally{if(o)throw l}}}return n}}]),t}(k);function z(e){!function e(t,a,n,i,r,s){if(a){if(i-n<2)return;var o=2*Math.floor(N(r,s)/2);!function(e,t,a,n){for(var i=2*Math.floor(N(t,a)/2)+1,r=2*Math.floor(N(t,a)/2)+1,s=t;s<=a;s++)s!==i&&s!==r&&e.toggleWall(n,s)}(t,n,i,o),e(t,!a,n,i,r,o-1),e(t,!a,n,i,o+1,s)}else{if(s-r<2)return;var l=2*Math.floor(N(n,i)/2);!function(e,t,a,n){for(var i=2*Math.floor(N(t,a)/2)+1,r=2*Math.floor(N(t,a)/2)+1,s=t;s<=a;s++)s!==i&&s!==r&&e.toggleWall(s,n)}(t,r,s,l),e(t,!a,n,l-1,r,s),e(t,!a,l+1,i,r,s)}}(e,!0,1,47,1,17),function(e,t,a){for(var n=0;n<a;n++)if(0===n||n===a-1)for(var i=0;i<t;i++)e.grid[n][i].isWall||e.toggleWall(n,i);else e.grid[n][0].isWall||e.toggleWall(n,0),e.grid[n][t-1].isWall||e.toggleWall(n,t-1)}(e,49,19)}function N(e,t){return Math.floor(Math.random()*(t-e+1)+e)}O.weighted=!0,O.text='Bellman-Ford\'s works on weighted graphs and guarantees\n  the shortest path. This algorithm works by iterating |V| - 1 times over\n  all edges in the graph. For each edge (u,v,w) it "relaxes" the edge\n  by checking to see if u.distance + w is less than v.distance.\n  If so, then v.distance is updated to hold u.distance + w.\n  For this visualization I consider a node visited the first time\n  one of its edges is relaxed.';var W=function(){function e(t,a,n){Object(o.a)(this,e),this.grid=this.initializeGrid(t,a,n)}return Object(l.a)(e,[{key:"initializeNode",value:function(e,t,a,n,i){var r="0";return a&&(r=Math.floor(5*Math.random())+1),{col:t,row:e,isEnd:e===i[0]&&t===i[1],isStart:e===n[0]&&t===n[1],isVisited:!1,isWall:!1,distance:1/0,previous:null,weight:r}}},{key:"initializeGrid",value:function(e,t,a){for(var n=[],i=0;i<19;i++){for(var r=[],s=0;s<49;s++)r.push(this.initializeNode(i,s,e,t,a));n.push(r)}return n}},{key:"toggleStart",value:function(e,t){this.grid[e][t].isStart=!this.grid[e][t].isStart}},{key:"toggleEnd",value:function(e,t){this.grid[e][t].isEnd=!this.grid[e][t].isEnd}},{key:"toggleWall",value:function(e,t){this.grid[e][t].isWall=!this.grid[e][t].isWall}}]),e}(),M=(a(55),[9,9]),B=[9,39],I=function(e){function t(e){var a;return Object(o.a)(this,t),(a=Object(d.a)(this,Object(u.a)(t).call(this,e))).state={algo:E,algoText:"Dijkstra's",speed:"fast",grid:new W(E.weighted,M,B),mouseIsPressed:!1,animator:new y,visualized:!1,start:M,end:B,movingStart:!1,movingEnd:!1},a.visualize=a.visualize.bind(Object(c.a)(a)),a.speedChange=a.speedChange.bind(Object(c.a)(a)),a.algoChange=a.algoChange.bind(Object(c.a)(a)),a.clearBoard=a.clearBoard.bind(Object(c.a)(a)),a.newWeights=a.newWeights.bind(Object(c.a)(a)),a.generateMaze=a.generateMaze.bind(Object(c.a)(a)),a}return Object(h.a)(t,e),Object(l.a)(t,[{key:"handleMouseDown",value:function(e,t){var a=this.state,n=a.grid,i=a.start,r=a.end;a.visualized||(e===i[0]&&t===i[1]?this.setState({movingStart:!0}):e===r[0]&&t===r[1]?this.setState({movingEnd:!0}):n.toggleWall(e,t),this.setState({grid:n,mouseIsPressed:!0}))}},{key:"handleMouseEnter",value:function(e,t){var a=this.state,n=a.grid,i=a.start,r=a.end,s=a.mouseIsPressed,o=a.movingStart,l=a.movingEnd,d=a.visualized;s&&!d&&(o?(n.toggleStart(e,t),n.toggleStart(i[0],i[1]),this.setState({start:[e,t],movingStart:!0})):l?(n.toggleEnd(e,t),n.toggleEnd(r[0],r[1]),this.setState({end:[e,t],movingEnd:!0})):n.toggleWall(e,t),this.setState({grid:n}))}},{key:"handleMouseUp",value:function(){this.state.visualized||this.setState({mouseIsPressed:!1,movingStart:!1,movingEnd:!1})}},{key:"algoChange",value:function(e){var t=this.state,a=t.grid,n=t.start,i=t.end;if(!t.visualized){var r=null,s=null,o=null;switch(this.unvisitNodes(!1,n,i),e){case"Dijkstra":r=E,s="Dijkstra's",o=new W(E.weighted,n,i);break;case"BFS":r=S,s="Breadth-First Search",o=new W(S.weighted,n,i);break;case"DFS":r=j,s="Depth-First Search",o=new W(j.weighted,n,i);break;case"Bellman-Ford":r=O,s="Bellman-Ford",o=new W(O.weighted,n,i);break;default:return}o=this.keepWalls(a,o),this.setState({algo:r,algoText:s,grid:o})}}},{key:"speedChange",value:function(e){var t=[0,0],a=t.visitedSpeed,n=t.shortestSpeed;switch(e){case"slow":a=100,n=500;break;case"average":a=50,n=250;break;case"fast":a=10,n=50;break;default:return}this.state.animator.updateSpeed(a,n)}},{key:"visualize",value:function(){var e=this,t=this.state,a=t.grid,n=t.algo,i=t.visualized,r=t.start,s=t.end,o=t.animator;if(!i){this.unvisitNodes(!1,r,s),this.setState({visualized:!0});var l=new n,d=a.grid[r[0]][r[1]],u=a.grid[s[0]][s[1]],c=l.traverse(a.grid,d,u),h=l.getShortestPath(d,u);o.animate(c,h);var v=Math.max(12.5*(c.length+h.length),5e3);setTimeout((function(){return e.setState({visualized:!1})}),v)}}},{key:"unvisitNodes",value:function(e,t,a){for(var n=this.state.grid,i=0;i<19;i++)for(var r=0;r<49;r++){var s=n.grid[i][r];document.getElementById("node-".concat(s.row,"-").concat(s.col)).className="node ",s.isVisited=!1,s.previous=null,s.distance=1/0,e?s.isWall=!1:s.isWall&&(document.getElementById("node-".concat(s.row,"-").concat(s.col)).className="node node-wall"),i===t[0]&&r===t[1]&&(document.getElementById("node-".concat(t[0],"-").concat(t[1])).className="node node-start",s.isStart=!0),i===a[0]&&r===a[1]&&(document.getElementById("node-".concat(a[0],"-").concat(a[1])).className="node node-end",s.isEnd=!0)}this.setState({grid:n,visualized:!1})}},{key:"clearBoard",value:function(){this.state.visualized||(this.unvisitNodes(!0,M,B),this.setState({start:M,end:B}))}},{key:"newWeights",value:function(){var e=this.state,t=e.grid,a=e.algo,n=e.start,i=e.end;if(!e.visualized){this.unvisitNodes(!1,n,i);for(var r=new W(a.weighted,n,i),s=0;s<19;s++)for(var o=0;o<49;o++)t.grid[s][o].isWall&&(r.grid[s][o].isWall=!0);this.setState({grid:r})}}},{key:"keepWalls",value:function(e,t){for(var a=0;a<19;a++)for(var n=0;n<49;n++)e.grid[a][n].isWall&&(t.grid[a][n].isWall=!0);return t}},{key:"generateMaze",value:function(e){var t=this.state,a=t.grid,n=t.start,i=t.end;switch(this.unvisitNodes(!0,n,i),e){case"Random":!function(e){for(var t=0;t<19;t++)for(var a=0;a<49;a++){var n=Math.random();(n<=.1||n>=.9)&&e.toggleWall(t,a)}}(a);break;case"RecursiveDivision":z(a);break;default:return}this.setState({grid:a}),this.unvisitNodes(!1,n,i)}},{key:"render",value:function(){var e=this,t=this.state,a=t.grid,n=t.mouseIsPressed,r=t.visualized,s=t.algo;return i.a.createElement("div",null,i.a.createElement(p,{visualize:this.visualize,changeAlgo:this.algoChange,changeSpeed:this.speedChange,clearBoard:this.clearBoard,changeWeights:this.newWeights,visualized:r,generateMaze:this.generateMaze}),i.a.createElement("h3",null,"The current algorithm is ",this.state.algoText,"."),i.a.createElement("div",{className:"information"},s.text),i.a.createElement("div",{className:"board"},a.grid.map((function(t,a){return i.a.createElement("div",{key:a},t.map((function(t,a){var r=t.row,s=t.col,o=t.isEnd,l=t.isStart,d=t.isWall,u=t.weight;return i.a.createElement(b,{key:a,col:s,row:r,isEnd:o,isStart:l,isWall:d,mouseIsPressed:n,onMouseDown:function(t,a){return e.handleMouseDown(t,a)},onMouseEnter:function(t,a){return e.handleMouseEnter(t,a)},onMouseUp:function(){return e.handleMouseUp()},weight:u})})))}))))}}]),t}(n.Component);var C=function(){return i.a.createElement("div",null,i.a.createElement("div",{className:"App"},i.a.createElement(I,null)))};Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));s.a.render(i.a.createElement(C,null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()})).catch((function(e){console.error(e.message)}))}},[[39,1,2]]]);
//# sourceMappingURL=main.7979f07c.chunk.js.map